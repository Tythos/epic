EPIC
====

Excellent packages in C++

Package Configuration
---------------------

Specific properties of a package are defined in the *epic.json* file, located
in its root folder. If no *epic.json* is defined, default values are used.

Building
--------

The Python interface to EPIC is straightforward::

 > import epic
 > p = epic.Package('.')
 > p.build()

You can modify properties of the *epic.Package* object, which are initially
assigned by overriding default packages with the contents of *epic.json*. The
above lines are nearly identical to the invocation within the *epic build*
command. The *epic.Package* constructor requires only a path (absolute or
relative) to a package path.

Folder Layout
-------------

A package folder does not require any organization at first. The
*Package.organize()* method, however, will enforce the following directory
structure for organizing package contents:

#. A *bin* folder will be created for storing binary executables resulting from
   the build process.
#. A *lib* folder will be created for storing static libraries for this
   particular package.
#. A *src* folder will be created to store all *.cpp* and *.h* files that do not
   begin with "test_" or "main_".
#. An *inc* folder will be created to store all external headers (eventually
   this will include a precompiled header aggregation from all *.h* referenced
   from a given entry header).
#. A *test* folder will be created to store all *.cpp* files that begin with
   "test_".
#. An *obj* folder will be created to store interim build products (object
   files, etc.).
#. A *README.rst* and *license* file will be created in the top-level folder,
   if they do not already exist.

All *.cpp* files that begin with "main_" will remain in the top-level folder.
These will be compiled against the package's static library to produce the 
executables located in the *bin* folder.

Build Configurations
--------------------

Basic package configuration properties defined in *epic.json* include things
like package dependencies. Specific build configurations can also be defined
under the *build* property. Default build configurations include architecture
(32 vs 64 bit) and variant (debug vs release). Optional build configurations
defined in *epic.json* specify properties for *Builder* objects, like
command-line flags. The JSON object key used to list these configurations under
the *build* property can be used from the command line when invoking the *epic
build* command::

 > epic build config=nameOfBuildPropertyKey
 > epic build arch=64
 > epic build arch=64 variant=release

All intermediate and final build artifacts will be cleaned before the build
process begins. All build artifacts will therefore be generated by the most
recent configuration of the build command.

Builders
--------

The *Builder* class defines a common interface for compilie and link steps as
invoked from a subprocess against specific compilers (i.e., GCC's *g++* or
MSVC's *cl* and *link*). Subclasses of *Builder* define how these steps are
implemented for specific compilers. You can define your own *Builder* subclass
to specify how *EPIC* can interface to an alternative compiler (LLVM is a good
candidate). A specific builder class can be specified from the *epic build*
command by specifying the class to be imported within Python::

 > epic build builder=my.custom.builders.LLVM

Other customized Builder subclasses could be defined to generate Code::Blocks
or MSVC project files, for example. We are excited to see what variations the
community creates and finds useful.

