"""Primary interaction point for epic behaviors, including logical models.
"""

import os
import re
import csv
import sys
import json
import datetime
from epic import params, compilers, linkers, archivers

class BuildGraph(object):
    """Encapsulates a set of vertices and edges determined by a build_graph.csv
       table provided to the constructor. Also stores operator configurations,
       which default to MSVC compiler/linker/archiver commands.
    """

    def __init__(self, root):
        """The build graph is defined by a set of vertices (artifacts) and edges
           (operations). Edges are defined in the build_graph.csv table, while vertices
           are backed out from those entries. Those vertices can be organized into
           three sets:

           * Vertices listed as "from" but not "to" are source artifacts. These
             should always be present and will never be modified by the build
             process.

           * Vertices listed as both "from" and "to" are intermediate artifacts.
             These may or may not be present at any given point in time, and will
             be generated by various operations in the build process.

           * Vertices listed as only "to" are final artifacts (build products).
             These may or may not be present at any given point in time, and will
             be generated by final operations in the build process.

           This constructor initializes the object with a list of vertices
           (file name strings) and edges (rows from the CSV, as a list of
           dictionaries).
        """
        self.root = os.path.abspath(root)
        packPath = self.root + "/build_graph.csv"
        with open(packPath, 'r') as f:
            dr = csv.DictReader(f)
            self.edges = [row for row in dr]
        froms = [e["from"] for e in self.edges]
        tos = [e["to"] for e in self.edges]
        self.vertices = list(set(froms + tos))
        self.operators = { # default names of operator modules
            "compiler": compilers.MsvcCl, # cpp=>obj
            "linker": linkers.MsvcLink, # obj=>exe
            "archiver": archivers.MsvcLib # obj=>lib
        }

    def assertTools(self):
        """Raises an exception if the cmdExe does not exist for each operator
           currently in the build graph configuration
        """
        for key in self.operators.keys():
            self.operators[key].assertExists()

    def getFinalVertices(self):
        """Analyzes edges to determine which vertices are listed only as "to".
        """
        finals = []
        for v in self.vertices:
            froms = [e for e in self.edges if e["from"] == v]
            tos = [e for e in self.edges if e["to"] == v]
            if len(froms) == 0 and 0 < len(tos):
                finals.append(v)
        return finals

    def getEdgesTo(self, to):
        """Returns the operations (edges) that generate the given to (vertex).
        """
        return [e for e in self.edges if e["to"] == to]

    def traverse(self, v, level=0):
        """For a given vertex, recurses to "from" vertices for the generating
           operation (if this vertex is not a source artifact). Then,
           determines if it must be re-generated by it's corresponding edge
           operation by comparision of "from" date modified against "to" date
           modified.
        """
        print("".join(["\t"] * level) + v)
        ei = self.getEdgesTo(v)
        if len(ei) == 0:
            # source artifact; degenerate case
            return
        # assert same operation for each edge
        oi = [e["action"] for e in ei]
        assert len(set(oi)) == 1, "Vertex %s must be generated by identical edge operations" % v
        vi = [e["from"] for e in ei]
        # recurse to edge "froms"
        fromDts = []
        for v_ in vi:
            # check source nodes--recurse, determine mod date
            self.traverse(v_, level+1)
            fullPath = os.path.abspath(self.root + "/%s" % v_)
            dateMod = datetime.datetime.fromtimestamp(os.path.getmtime(fullPath))
            fromDts.append(dateMod)
        # compare "from" dates against "to" dates (assuming it exists)
        fullPath = os.path.abspath(self.root + "/%s" % v)
        isExists = os.path.isfile(fullPath)
        isRebuildNeeded = not isExists
        # rebuild is needed if any source artifacts have been modified after this vertex
        if isExists:
            toDt = datetime.datetime.fromtimestamp(os.path.getmtime(fullPath))
            isRebuildNeeded = any([toDt < dt for dt in fromDts])
        if isRebuildNeeded:
            self.buildVertex(v, ei)

    def buildVertex(self, v, ei):
        """Executes an operation to build the given vertex. This is mainly
           branching logic to specific "operator" functions.
        """
        # assert same operation for each edge
        oi = [e["action"] for e in ei]
        assert len(set(oi)) == 1, "Vertex %s must be generated by identical edge operations" % v
        vi = [e["from"] for e in ei]
        operation = oi[0]
        operator = None
        if operation == "compile":
            # compiler operations should be 1-to-1
            assert len(vi) == 1, "Compile operations are 1-to-1 transformations ('%s')" % v
            operator = self.operators["compiler"]()
        elif operation == "link":
            # linker operations can be n-to-1
            operator = self.operators["linker"]()
        elif operation == "archive":
            # archive operations can be n-to-1
            operator = self.operators["archiver"]()
        else:
            raise Exception("Unsupported operation '%s' to generate artifact '%s'" % (operation, v))
        # adjust paths of verticies to project root
        operator.execute([
            os.path.abspath(self.root + "/" + i) for i in vi
        ], os.path.abspath(self.root + "/" + v)) # ["from"], "to"

    def getIntermediateVertices(self):
        """Returns a list of all intermediate vertices (build products), as
           determined by those with both "to" and "from edge connections.
        """
        intermediates = []
        for v in self.vertices:
            froms = [e for e in self.edges if e["from"] == v]
            tos = [e for e in self.edges if e["to"] == v]
            if 0 < len(tos) and 0 < len(froms):
                intermediates.append(v)
        return intermediates

def build(root):
    """Initializes a recursive traversal of the build graph, walking backwards
       from each final vertex.
    """
    bg = BuildGraph(root)
    finals = bg.getFinalVertices()
    for v in finals:
        bg.traverse(v)

def clean(root, rmAll=False):
    """Deletes all intermediate build products from the package folder. If
       rmAll is True, also removes all final build products.
    """
    bg = BuildGraph(root)
    vi = bg.getIntermediateVertices()
    for v in vi:
        fullPath = bg.root + "/%s" % v
        if os.path.isfile(fullPath):
            os.remove(fullPath)
    if rmAll:
        vi = bg.getFinalVertices()
        for v in vi:
            fullPath = bg.root + "/%s" % v
            if os.path.isfile(fullPath):
                os.remove(fullPath)

def init(root):
    """Creates a new build_graph.csv table in the given folder. (An error is
       thrown if one already exists.) This build graph assumes the following:

       #. All ".cpp" files are compiled to ".obj" files

       #. All ".obj" files that don't begin with "main_" are archived into a
          static library named after the package folder

       #. All ".obj" files that begin with "main_" are linked against the
          package's static library to generate an ".exe" program, whose name
          matches the original "main_*.cpp" but without the "main_" prefix and
          with a different file extension (".exe" by default).
    """
    bgPath = os.path.abspath(root) + "/build_graph.csv"
    if os.path.isfile(bgPath):
        raise Exception("A build graph already exists for '%s'" % root)
    mains = []
    others = []
    for filename in os.listdir():
        if filename.endswith(".cpp"):
            if filename.startswith("main_"):
                mains.append(filename)
            else:
                others.append(filename)
    # now, build entries (edges) in build graph
    _, name = os.path.split(os.path.abspath(root))
    lib = name + ".lib"
    edges = []
    for cpp in others:
        obj = re.sub("\.cpp$", ".obj", cpp)
        edges.append({
            "from": cpp,
            "to": obj,
            "action": "compile"
        })
        edges.append({
            "from": obj,
            "to": lib,
            "action": "archive"
        })
    for cpp in mains:
        obj = re.sub("\.cpp$", ".obj", cpp)
        exe = re.sub("\.cpp$", ".exe", cpp)
        exe = re.sub("^main_", "", exe)
        edges.append({
            "from": cpp,
            "to": obj,
            "action": "compile"
        })
        edges.append({
            "from": obj,
            "to": exe,
            "action": "link"
        })
        edges.append({
            "from": lib,
            "to": exe,
            "action": "link"
        })
    # write edges out to build graph
    with open(bgPath, 'w') as f:
        dw = csv.DictWriter(f, lineterminator="\n", fieldnames=list(edges[0].keys()))
        dw.writeheader()
        dw.writerows(edges)
    
def main(root, action, options=[]):
    """Performs a specific action against a package root. A list of optional
       action-specific arguments can also be provided.
    """
    if action == "build":
        build(root)
    elif action == "clean":
        clean(root, "--all" in options)
    elif action == "init":
        init(root)
    else:
        raise Exception("Unsupported action '%s'" % action)

if __name__ == "__main__":
    p = params.Params(sys.argv)
    root = p.get("root")
    action = p.get("action")
    main(root, action, p.argv)
